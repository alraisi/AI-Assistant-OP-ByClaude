import { GoogleGenAI } from '@google/genai';
import type {
  LLMProvider,
  ChatRequest,
  ChatResponse,
  DocumentAnalysisProvider,
  DocumentAnalysisRequest,
  DocumentAnalysisResponse,
  ImageGenerationProvider,
  ImageGenerationRequest,
  ImageGenerationResponse,
} from './types.js';
import { getConfig } from '../config/index.js';
import { withRetry } from '../utils/retry.js';
import pino from 'pino';

const logger = pino({ name: 'gemini-provider' });

export class GeminiProvider implements LLMProvider, DocumentAnalysisProvider, ImageGenerationProvider {
  private ai: GoogleGenAI;
  private model: string;
  private imageModel: string;

  constructor() {
    const config = getConfig();
    if (!config.geminiApiKey) {
      throw new Error('GEMINI_API_KEY is required to use Gemini provider');
    }
    this.ai = new GoogleGenAI({ apiKey: config.geminiApiKey });
    this.model = config.geminiModel;
    this.imageModel = config.geminiImageModel;
  }

  async chat(request: ChatRequest): Promise<ChatResponse> {
    const contents = request.messages.map((msg) => ({
      role: msg.role === 'assistant' ? 'model' as const : 'user' as const,
      parts: [{ text: msg.content }],
    }));

    const response = await withRetry(
      () => this.ai.models.generateContent({
        model: this.model,
        contents,
        config: {
          systemInstruction: request.systemPrompt,
          maxOutputTokens: request.maxTokens || 1024,
        },
      }),
      { timeoutMs: 90_000, maxRetries: 3, label: 'gemini-chat' }
    );

    const content = response.text ?? '';

    return {
      content,
      usage: response.usageMetadata ? {
        inputTokens: response.usageMetadata.promptTokenCount ?? 0,
        outputTokens: response.usageMetadata.candidatesTokenCount ?? 0,
      } : undefined,
    };
  }

  async analyzeDocument(request: DocumentAnalysisRequest): Promise<DocumentAnalysisResponse> {
    const isPDF = request.mimeType === 'application/pdf';

    let parts: Array<{ text: string } | { inlineData: { mimeType: string; data: string } }>;

    if (isPDF) {
      // Send raw PDF buffer via inlineData (Gemini native PDF support)
      parts = [
        {
          inlineData: {
            mimeType: 'application/pdf',
            data: request.documentBuffer.toString('base64'),
          },
        },
        { text: request.prompt },
      ];
    } else {
      // Send pre-extracted text for all other formats
      parts = [
        { text: `Document: ${request.fileName}\nFormat: ${request.mimeType}\n\nContent:\n${request.extractedText}` },
        { text: request.prompt },
      ];
    }

    const response = await withRetry(
      () => this.ai.models.generateContent({
        model: this.model,
        contents: [{ role: 'user', parts }],
        config: {
          systemInstruction: request.systemPrompt || 'You are a helpful assistant that analyzes documents and provides detailed, accurate responses.',
          maxOutputTokens: request.maxTokens || 4096,
        },
      }),
      { timeoutMs: 120_000, maxRetries: 3, label: 'gemini-document' }
    );

    const content = response.text ?? '';

    logger.info({
      fileName: request.fileName,
      mimeType: request.mimeType,
      isPDF,
      inputTokens: response.usageMetadata?.promptTokenCount,
      outputTokens: response.usageMetadata?.candidatesTokenCount,
    }, 'Document analyzed');

    return {
      content,
      usage: response.usageMetadata ? {
        inputTokens: response.usageMetadata.promptTokenCount ?? 0,
        outputTokens: response.usageMetadata.candidatesTokenCount ?? 0,
      } : undefined,
    };
  }

  async generateImage(request: ImageGenerationRequest): Promise<ImageGenerationResponse> {
    logger.info({ prompt: request.prompt.slice(0, 100), model: this.imageModel }, 'Generating image with Gemini');

    try {
      const response = await withRetry(
        () => this.ai.models.generateContent({
          model: this.imageModel,
          contents: [{ role: 'user', parts: [{ text: request.prompt }] }],
          config: {
            responseModalities: ['Text', 'Image'],
          },
        }),
        { timeoutMs: 120_000, maxRetries: 2, label: 'gemini-image-gen' }
      );

      // Extract image from response
      const candidate = response.candidates?.[0];
      if (!candidate?.content?.parts) {
        throw new Error('No image generated by Gemini - empty response');
      }

      // Find the image part
      for (const part of candidate.content.parts) {
        if (part.inlineData?.data) {
          const imageData = part.inlineData.data;
          const mimeType = part.inlineData.mimeType || 'image/png';
          
          logger.info({ 
            mimeType, 
            size: imageData.length,
            prompt: request.prompt.slice(0, 50) 
          }, 'Image generated with Gemini');

          return {
            imageBuffer: Buffer.from(imageData, 'base64'),
            revisedPrompt: request.prompt,
          };
        }
      }

      throw new Error('No image data in Gemini response');
    } catch (error) {
      logger.error({ error }, 'Gemini image generation failed');
      throw error;
    }
  }
}

let instance: GeminiProvider | null = null;

export function getGeminiProvider(): GeminiProvider {
  if (!instance) {
    instance = new GeminiProvider();
  }
  return instance;
}
